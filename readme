# Proyecto: Divisi√≥n en P√°rrafos
## An√°lisis y Dise√±o de Algoritmos

---

## üìã Descripci√≥n del Proyecto

Este proyecto implementa y compara **cuatro algoritmos diferentes** para resolver el problema de Divisi√≥n en P√°rrafos:

1. **Algoritmo Iterativo** (Programaci√≥n Din√°mica Bottom-Up)
2. **Algoritmo Recursivo Puro** (Sin memorizaci√≥n)
3. **Algoritmo Divide y Vencer√°s** (Con memoizaci√≥n)
4. **Algoritmo Exhaustivo** (Fuerza bruta)

### Problema

Dada una secuencia de palabras con longitudes `l‚ÇÅ, l‚ÇÇ, ..., l‚Çñ`, se desea agruparlas en l√≠neas de longitud `L`. Las palabras est√°n separadas por espacios cuya amplitud ideal es `b`, pero pueden ajustarse. El objetivo es minimizar el costo total de ajuste de espacios.

**Funci√≥n de Costo:**
- Para una l√≠nea con palabras `p·µ¢, p·µ¢‚Çä‚ÇÅ, ..., p‚±º`: costo = `(j-i) ¬∑ |b' - b|`
- Donde `b' = (L - Œ£longitudes) / (j-i)`
- La √∫ltima l√≠nea tiene costo 0 (a menos que `b' < 0`, que es inv√°lido)

---

## üìÅ Estructura del Proyecto

```
proyecto-division-parrafos/
‚îÇ
‚îú‚îÄ‚îÄ implementacion.py         # Implementaci√≥n de los 4 algoritmos
‚îú‚îÄ‚îÄ test_division_parrafos.py    # Suite de pruebas con pytest
‚îú‚îÄ‚îÄ analisis_graficas.py         # An√°lisis de rendimiento y gr√°ficas
‚îú‚îÄ‚îÄ README.md                    # Este archivo
‚îú‚îÄ‚îÄ requirements.txt             # Dependencias del proyecto
‚îÇ
‚îî‚îÄ‚îÄ resultados/                  # (generado al ejecutar)
    ‚îú‚îÄ‚îÄ analisis_division_parrafos.png
    ‚îî‚îÄ‚îÄ resultados_benchmark.json
```

---

## üõ†Ô∏è Instalaci√≥n

### Prerrequisitos

- Python 3.8 o superior
- pip (gestor de paquetes de Python)

### Paso 1: Clonar o descargar el proyecto

```bash
# Si usas git
git clone <url-del-repositorio>
cd proyecto-division-parrafos
```

### Paso 2: Crear entorno virtual (recomendado)

```bash
# En Windows
python -m venv venv
venv\Scripts\activate

# En macOS/Linux
python3 -m venv venv
source venv/bin/activate
```

### Paso 3: Instalar dependencias

```bash
pip install -r requirements.txt
```

**Contenido de `requirements.txt`:**
```
pytest>=7.0.0
matplotlib>=3.5.0
numpy>=1.21.0
```

---

## üöÄ Uso del Proyecto

### 1. Ejecutar el programa principal

Ejecuta los 4 algoritmos con casos de prueba predefinidos:

```bash
python division_parrafos.py
```

**Salida esperada:**
- Comparaci√≥n de los 4 algoritmos en casos peque√±os
- Comparaci√≥n de algoritmos eficientes en casos medianos
- Tabla de complejidades te√≥ricas
- Visualizaci√≥n de la soluci√≥n √≥ptima

### 2. Ejecutar pruebas con pytest

```bash
# Ejecutar todas las pruebas
pytest test_division_parrafos.py -v

# Ejecutar con m√°s detalles
pytest test_division_parrafos.py -v --tb=short

# Ejecutar pruebas espec√≠ficas
pytest test_division_parrafos.py::TestAlgoritmoIterativo -v

# Ver cobertura (requiere pytest-cov)
pytest test_division_parrafos.py --cov=division_parrafos --cov-report=html
```

### 3. Generar an√°lisis y gr√°ficas

```bash
python analisis_graficas.py
```

**Esto generar√°:**
- ‚úÖ 6 gr√°ficas comparativas en un solo archivo PNG
- ‚úÖ Tabla comparativa de rendimiento
- ‚úÖ Informe completo con conclusiones
- ‚úÖ Archivo JSON con todos los datos

---

## üìä Gr√°ficas Generadas

El m√≥dulo `analisis_graficas.py` genera 6 gr√°ficas:

1. **Tiempo vs Tama√±o (Escala Log)** - Muestra crecimiento exponencial de algoritmos ineficientes
2. **Tiempo vs Tama√±o (Escala Lineal)** - Comparaci√≥n directa de tiempos
3. **Comparaci√≥n de Costos** - Verifica que todos dan el mismo resultado √≥ptimo
4. **Speedup Relativo** - Cu√°ntas veces m√°s lento es cada algoritmo vs Iterativo
5. **Tiempo Acumulado** - Barras apiladas mostrando contribuci√≥n total
6. **Eficiencia (tiempo/n¬≤)** - Normalizada por complejidad cuadr√°tica

---

## üß™ Casos de Prueba

### Caso Peque√±o (todos los algoritmos)
```python
palabras = [5, 3, 4, 6, 2]
L = 15
b = 1.5
```

### Caso Mediano (solo algoritmos eficientes)
```python
palabras = [3, 4, 2, 5, 3, 4, 6, 2, 3, 5]
L = 20
b = 2.0
```

### Personalizar casos

```python
from division_parrafos import DivisionParrafos

# Crear instancia con tus datos
dp = DivisionParrafos(
    palabras=[5, 3, 4, 6, 2, 3],
    L=20,
    b=1.5
)

# Resolver con el algoritmo que prefieras
costo, cortes = dp.resolver_iterativo()
print(f"Costo √≥ptimo: {costo}")
print(f"Puntos de corte: {cortes}")
```

---

## üìà Complejidad de los Algoritmos

| Algoritmo | Complejidad Temporal | Complejidad Espacial | Uso Recomendado |
|-----------|---------------------|---------------------|-----------------|
| **Iterativo (DP)** | O(n¬≤) | O(n) | ‚úÖ **PRODUCCI√ìN** |
| **Recursivo Puro** | O(2‚Åø) | O(n) stack | ‚ö†Ô∏è Solo demostraci√≥n (n ‚â§ 10) |
| **Divide y Vencer√°s** | O(n¬≤) | O(n¬≤) | ‚úÖ Alternativa v√°lida |
| **Exhaustivo** | O(B(n))* | O(n) | ‚ùå Solo n ‚â§ 5 |

*B(n) = N√∫mero de Bell (particiones de conjunto)

---

## üß© Estructura del C√≥digo

### `division_parrafos.py`

#### Clase Principal: `DivisionParrafos`

```python
class DivisionParrafos:
    def __init__(self, palabras: List[int], L: int, b: float)
    
    # M√©todo auxiliar
    def calcular_costo_linea(self, i: int, j: int) -> float
    
    # 4 algoritmos principales
    def resolver_iterativo(self) -> Tuple[float, List[int]]
    def resolver_recursivo(self) -> Tuple[float, List[int]]
    def resolver_divide_venceras(self) -> Tuple[float, List[int]]
    def resolver_exhaustivo(self) -> Tuple[float, List[int]]
```

#### Funciones Auxiliares

```python
def ejecutar_y_medir(algoritmo_func, nombre: str) -> Dict
def mostrar_solucion(palabras, cortes, L, b)
def ejecutar_comparacion()  # Funci√≥n principal
```

---

## üß™ Suite de Pruebas (pytest)

### Categor√≠as de Tests

1. **TestCalculoCosto** - Verifica c√°lculo correcto de costos
2. **TestAlgoritmoIterativo** - Tests del algoritmo DP
3. **TestAlgoritmoRecursivo** - Tests del recursivo puro
4. **TestAlgoritmoDivideVenceras** - Tests D&V
5. **TestAlgoritmoExhaustivo** - Tests exhaustivo
6. **TestCasosEspeciales** - Edge cases
7. **TestRendimiento** - Benchmarks de tiempo
8. **TestValidacionResultados** - Validaci√≥n de outputs

### Ejecutar Subconjuntos de Tests

```bash
# Solo tests de iterativo
pytest test_division_parrafos.py::TestAlgoritmoIterativo -v

# Solo tests de casos especiales
pytest test_division_parrafos.py::TestCasosEspeciales -v

# Tests que contienen "costo" en el nombre
pytest test_division_parrafos.py -k "costo" -v
```

---

## üìä Resultados Esperados

### Tiempo de Ejecuci√≥n (aproximado)

Para `n = 20` palabras:
- **Iterativo:** ~0.5 ms ‚úÖ
- **Divide y Vencer√°s:** ~1.5 ms ‚úÖ
- **Recursivo:** ~30,000 ms ‚ö†Ô∏è
- **Exhaustivo:** No termina ‚ùå

### Conclusiones del An√°lisis

1. ‚úÖ **Iterativo es el ganador** - M√°s r√°pido y eficiente
2. ‚ö†Ô∏è **Recursivo puro es impracticable** para n > 10
3. ‚ö†Ô∏è **Exhaustivo solo sirve para demostraci√≥n** (n ‚â§ 5)
4. ‚úÖ **Divide y Vencer√°s es competitivo** pero con m√°s overhead
5. üéØ **Todos encuentran el mismo costo √≥ptimo** (validaci√≥n correcta)

---

## üé® Personalizaci√≥n

### Cambiar par√°metros de benchmark

Edita `analisis_graficas.py`:

```python
def main():
    analizador = AnalizadorRendimiento()
    
    # Personaliza estos valores
    tama√±os = [3, 5, 8, 10, 15, 20, 30, 40, 50]  # Agregar m√°s tama√±os
    L = 25  # Cambiar longitud de l√≠nea
    b = 1.5  # Cambiar amplitud ideal
    
    analizador.ejecutar_benchmark(tama√±os, L=L, b=b)
    # ...
```

### Agregar nuevos tests

En `test_division_parrafos.py`:

```python
def test_mi_caso_especial():
    """Descripci√≥n del test"""
    dp = DivisionParrafos([...], L=..., b=...)
    costo, cortes = dp.resolver_iterativo()
    assert costo < float('inf')
    # ... m√°s aserciones
```

---

## üêõ Soluci√≥n de Problemas

### Error: ModuleNotFoundError

```bash
# Aseg√∫rate de tener instaladas las dependencias
pip install -r requirements.txt
```

### Error: "No module named 'division_parrafos'"

```bash
# Aseg√∫rate de estar en el directorio correcto
cd proyecto-division-parrafos

# O agrega el path manualmente
export PYTHONPATH="${PYTHONPATH}:$(pwd)"  # Linux/Mac
set PYTHONPATH=%PYTHONPATH%;%cd%  # Windows
```

### Gr√°ficas no se muestran

```python
# Si usas SSH o entorno sin GUI, guarda sin mostrar:
plt.savefig('grafica.png')
# Comenta: plt.show()
```

---

## üìö Referencias

- **Programaci√≥n Din√°mica:** Cormen, T. H., et al. "Introduction to Algorithms"
- **Divide y Vencer√°s:** Problema de l√≠neas √≥ptimas (Knuth-Plass)
- **Complejidad:** An√°lisis asint√≥tico y notaci√≥n Big-O

---

## üë®‚Äçüíª Autor

Proyecto desarrollado para el curso de An√°lisis y Dise√±o de Algoritmos

---

## üìù Licencia

Este proyecto es de uso acad√©mico.

---

## üéØ Checklist del Proyecto

- [x] ‚úÖ Algoritmo Iterativo (Programaci√≥n Din√°mica)
- [x] ‚úÖ Algoritmo Recursivo Puro
- [x] ‚úÖ Algoritmo Divide y Vencer√°s
- [x] ‚úÖ Algoritmo Exhaustivo
- [x] ‚úÖ Mediciones de tiempo
- [x] ‚úÖ Comparaci√≥n de rendimiento
- [x] ‚úÖ Gr√°ficas de an√°lisis
- [x] ‚úÖ Suite de tests con pytest
- [x] ‚úÖ Documentaci√≥n completa
- [x] ‚úÖ Casos de prueba variados
- [x] ‚úÖ An√°lisis de complejidad

---

## üöÄ Pr√≥ximos Pasos (Opcional)

1. Implementar visualizaci√≥n interactiva con tkinter
2. Agregar soporte para diferentes m√©tricas de costo
3. Exportar resultados a PDF
4. Crear API REST para el servicio
5. Implementar paralelizaci√≥n para entradas muy grandes

---

**¬°Proyecto completo y listo para entregar! üéâ**